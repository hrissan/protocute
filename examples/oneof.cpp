// This file is generated by https://github.com/hrissan/protocute

#include "oneof.hpp"
#include "protocute.hpp"

namespace protocute {

void read(::test123::Types & v, iterator s, iterator e){
	while(s != e){
		auto m = read_varint(&s, e);
		auto field_type = static_cast<unsigned>(m & 7U);
		auto field_number = static_cast<unsigned>(m >> 3U);
		if(field_number == 1 && field_type == 0)
			v.value1 = read_varint_t<int32_t>(&s, e);
		else if(field_number == 2 && field_type == 2)
			read_packed_varint(v.value2, &s, e);
		else if(field_number == 2 && field_type == 0)
			v.value2.push_back(read_varint(&s, e));
		else if(field_number == 3 && field_type == 0)
			v.side = read_varint_t<::test123::Side>(&s, e);
		else if(field_number == 4 && field_type == 2)
			v.str = read_string(&s, e);
		else if(field_number == 5 && field_type == 0)
			v.boo = read_varint(&s, e) != 0;
		else if(field_number == 6 && field_type == 2)
			v.bite = read_string(&s, e);
		else if(field_number == 7 && field_type == 5)
			v.num1 = read_fixed<float>(&s, e);
		else if(field_number == 8 && field_type == 2)
			read_packed_fixed(v.num2, &s, e);
		else if(field_number == 8 && field_type == 1)
			v.num2.push_back(read_fixed<double>(&s, e));
		else 
			skip_by_type(field_type, &s, e);
	}

}

std::string write(const ::test123::Types & v){
	std::string s;
	if(v.value1 != 0)
		write_field_varint(1, static_cast<uint64_t>(static_cast<int64_t>(v.value1)), s);
	write_packed_varint(2, v.value2, s);
	if(v.side != ::test123::Side::LEFT)
		write_field_varint(3, static_cast<uint64_t>(v.side), s);
	write_field_string(4, v.str, s);
	if(v.boo)
		write_field_varint(5, v.boo ? 1 : 0, s);
	write_field_string(6, v.bite, s);
	if(v.num1 != 0)
		write_field_fixed32(7, &v.num1, s);
	write_packed_fixed(8, v.num2, s);
	return s;
}

void read(::test123::Point & v, iterator s, iterator e){
	while(s != e){
		auto m = read_varint(&s, e);
		auto field_type = static_cast<unsigned>(m & 7U);
		auto field_number = static_cast<unsigned>(m >> 3U);
		if(field_number == 1 && field_type == 0)
			v.x = read_varint_t<int64_t>(&s, e);
		else if(field_number == 2 && field_type == 0)
			v.y = read_varint_t<int64_t>(&s, e);
		else if(field_number == 3 && field_type == 0)
			v.z = read_varint_t<int64_t>(&s, e);
		else 
			skip_by_type(field_type, &s, e);
	}

}

std::string write(const ::test123::Point & v){
	std::string s;
	if(v.x != 0)
		write_field_varint(1, static_cast<uint64_t>(v.x), s);
	if(v.y != 0)
		write_field_varint(2, static_cast<uint64_t>(v.y), s);
	if(v.z)
		write_field_varint(3, static_cast<uint64_t>(*v.z), s);
	return s;
}

void read(::test123::Something & v, iterator s, iterator e){
	while(s != e){
		auto m = read_varint(&s, e);
		auto field_type = static_cast<unsigned>(m & 7U);
		auto field_number = static_cast<unsigned>(m >> 3U);
		if(field_number == 1 && field_type == 2)
			v.position.emplace<1>() = read_string(&s, e);
		else if(field_number == 2 && field_type == 2)
			v.position.emplace<2>() = read_string(&s, e);
		else if(field_number == 3 && field_type == 2)
			read_message(v.position.emplace<3>(), &s, e);
		else 
			skip_by_type(field_type, &s, e);
	}

}

std::string write(const ::test123::Something & v){
	std::string s;
	switch(v.position.index()){
	case 1:
		write_field_string(1, std::get<1>(v.position), s);
		break;
	case 2:
		write_field_string(2, std::get<2>(v.position), s);
		break;
	case 3:
		write_field_string(3, write(std::get<3>(v.position)), s);
		break;
	default:
		break;
	}
	return s;
}

} // namespace protocute

