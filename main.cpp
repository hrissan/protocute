#include "proto.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <complex>
#include <unistd.h>

static std::string boast = "// This file is generated by https://github.com/hrissan/protocute\n\n";

static std::string stream_forward_def = "\nnamespace protocute { struct IStream; struct OStream; }\n\n";

static std::string stream_def = R"(

	namespace protocute {
	struct IStream {
		virtual void read(void *data, size_t size)=0;
	};
	struct OStream {
		virtual void write(const void *data, size_t size)=0;
	};
	} // namespace protocute

)";


struct Namespace;

struct Namespace {
	enum Type { PACKAGE, MESSAGE, ENUM };
	Type type = PACKAGE;
	std::string fullname;
	std::map<std::string, std::unique_ptr<Namespace>> member;
	
	std::string enum_default_value;
};

struct CodeGenerator {
	std::ostream& hpp;
	std::ostream& cpp;
	
	std::vector<std::string> current_package;
	
	Namespace root_namespace;
	std::vector<Namespace *> current_namespace;
	size_t indent = 0; // signle indent for a::b::c::d
	
	struct EnumGenerator {
		CodeGenerator & cg;
		explicit EnumGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s) {}
		void operator()(GEnum const& s);
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};
	struct MessageGenerator {
		CodeGenerator & cg;
		explicit MessageGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s) {}
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s);
		void operator()(GEmptyStatement const& s) {}
	};
	struct FieldGenerator {
		CodeGenerator & cg;
		explicit FieldGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s);
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};

	void close_package(){
		if(current_package.empty())
			return;
		hpp << std::string(current_package.size(), '}') << " // ";
		std::string fullname;
		for(const auto & s : current_package){
			if(!fullname.empty())
				fullname += "::";
			fullname += s;
		}
		hpp << fullname << "\n\n";
		current_package.clear();
		current_namespace = {&root_namespace};
		indent = 0;
	}
	explicit CodeGenerator(std::ostream& hpp, std::ostream& cpp):hpp(hpp), cpp(cpp) {
		hpp << boast;
		hpp << "#include <string>\n";
		hpp << "#include <vector>\n";
		hpp << "#include <cstdint>\n\n";
		
		hpp << stream_forward_def;
		
		cpp << boast;
		
		cpp << "#include \"c.hpp\"\n\n";
		
		cpp << "namespace protocute {\n\n";
		current_namespace = {&root_namespace};
	}
	
	void operator()(GImport const& s) {}
	void operator()(std::string const& s)
	{
		close_package();
		if(!parse_ident_split(s, current_package))
			throw std::runtime_error("Error parsing package name {" + s + "}");
		for(const auto & s : current_package){
			hpp << "namespace " << s << " { ";
			auto cn = current_namespace.back();
			auto cit = cn->member.find(s);
			if(cit == cn->member.end())
				cit = cn->member.emplace(s, std::make_unique<Namespace>()).first;
			cit->second->fullname = cn->fullname + "::" + s;
			if(cit->second->type != Namespace::PACKAGE)
				throw std::runtime_error("Package name collision with non-package");
			current_namespace.push_back(cit->second.get());
		}
		hpp << "\n\n";
		indent = 1;
	}
	void operator()(GOption const& s)
	{
	}
	void operator()(GEnum const& s){
		auto cn = current_namespace.back();
		auto cit = cn->member.find(s.name);
		if(cit != cn->member.end())
			throw std::runtime_error("Enum name collision");
		cit = cn->member.emplace(s.name, std::make_unique<Namespace>()).first;
		cit->second->fullname = cn->fullname + "::" + s.name;
		cit->second->type = Namespace::ENUM;
		hpp << std::string(indent, '\t') << "enum " << s.name << " { \n";
		for(const auto & f : s.fields)
			if(f.type() == typeid(GEnumField)){
				const auto & ef = boost::get<GEnumField>(f);
				if(cit->second->enum_default_value.empty())
					cit->second->enum_default_value = ef.value;
				hpp << std::string(indent + 1, '\t') << ef.name << " = " << ef.value << ";\n";
			}
//			else if(f.type() == typeid(GOption))
//				stream << boost::get<GOption>(f) << "|";
		hpp << std::string(indent, '\t') << "};\n\n";
	}
	void operator()(GMessage const& s){
		hpp << std::string(indent, '\t') << "class " << s.name << " { \n";
		auto cn = current_namespace.back();
		auto cit = cn->member.find(s.name);
		if(cit != cn->member.end())
			throw std::runtime_error("Message name collision");
		cit = cn->member.emplace(s.name, std::make_unique<Namespace>()).first;
		cit->second->fullname = cn->fullname + "::" + s.name;
		cit->second->type = Namespace::MESSAGE;
		current_namespace.push_back(cit->second.get());
		indent += 1;

		EnumGenerator eg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(eg, f);
		MessageGenerator mg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(mg, f);
		FieldGenerator fg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(fg, f);
		
		cpp << "\tvoid read(" << cit->second->fullname << " & v, IStream * s){\n";
		cpp << "\t}\n\n";
		cpp << "\tvoid write(const " << cit->second->fullname << " & v, OStream * s){\n";
		cpp << "\t}\n\n";
		current_namespace.pop_back();
		indent -= 1;
		hpp << std::string(indent, '\t') << "};\n\n";
	}
	void operator()(GEmptyStatement const& s) {}
	void generate_field(GField const& s){
		hpp << std::string(indent, '\t');
		if(s.kind == GFieldKind::REPEATED){
			hpp << "std::vector<";
		}
		std::string def;
		if(s.type == "double") { hpp << "double"; def = "0"; }
		else if(s.type == "float") { hpp << "float"; def = "0"; }
		else if(s.type == "int32" || s.type == "sint32" || s.type == "sfixed32") { hpp << "int32_t"; def = "0"; }
		else if(s.type == "int64" || s.type == "sint64" || s.type == "sfixed64") { hpp << "int64_t"; def = "0"; }
		else if(s.type == "uint32" || s.type == "fixed32") { hpp << "uint32_t"; def = "0"; }
		else if(s.type == "uint64" || s.type == "fixed64") { hpp << "uint64_t"; def = "0"; }
		else if(s.type == "bool") { hpp << "bool"; def = "false"; }
		else if(s.type == "string") hpp << "std::string";
		else if(s.type == "bytes") hpp << "std::string";
		else {
			std::string str = s.type;
			if(str.empty())
				throw std::runtime_error("Type cannot be empty");
			size_t pos = current_namespace.size();
			if(str.at(0) == '.'){
				pos = 1;
				str.erase(str.begin());
			}
			std::vector<std::string> full_ident;
			if(!parse_ident_split(str, full_ident) || full_ident.empty())
				throw std::runtime_error("Error parsing full identifer name {" + str + "}");
			Namespace * found_cn = nullptr;
			for(size_t i = pos; i-- > 0; ){
				auto cn = current_namespace.at(i);
				auto cit = cn->member.find(full_ident.at(0));
				if(cit != cn->member.end()){
					found_cn = cit->second.get();
					full_ident.erase(full_ident.begin());
					while(!full_ident.empty()){
						auto cit = found_cn->member.find(full_ident.at(0));
						if(cit == found_cn->member.end())
							throw std::runtime_error("Type not found - " + s.type);
						found_cn = cit->second.get();
						full_ident.erase(full_ident.begin());
					}
					break;
				}
			}
			if(!found_cn)
				throw std::runtime_error("Type not found - " + s.type);
			if(found_cn->type == Namespace::PACKAGE)
				throw std::runtime_error("Type specified is a package - " + s.type);
			hpp << s.type; // TODO - fully qualified
			if(found_cn->type == Namespace::ENUM)
				def = found_cn->enum_default_value;
		}
		if(s.kind == GFieldKind::REPEATED){
			hpp << ">";
		}
		hpp << " " << s.name;
		if(!def.empty())
			hpp << " = " << def;
		hpp << ";\n";
	}
	void gen_defs(const Namespace & na){
		if(na.type == Namespace::MESSAGE){
			hpp << "\tvoid read(" << na.fullname << " & v, IStream * s);\n";
			hpp << "\tvoid write(const " << na.fullname << " & v, OStream * s);\n\n";
		}
		for(const auto & m : na.member){
			gen_defs(*m.second.get());
		}
	}
	void finish_header(){
		close_package();
		hpp << "namespace protocute {\n\n";
		gen_defs(root_namespace);
		hpp << "} // namespace protocute\n\n";
		
		cpp << "} // namespace protocute\n\n";
	}
};

void CodeGenerator::EnumGenerator::operator()(GEnum const& s){
	cg.operator()(s);
}

void CodeGenerator::MessageGenerator::operator()(GMessage const& s) {
	cg.operator()(s);
}

void CodeGenerator::FieldGenerator::operator()(GField const& s){
	cg.generate_field(s);
}

//void generate_header(std::ostream& stream, const GProtoFile& val) {
//	stream << "GMessage{" << val.name << "|";
//	for(const auto & s : val.fields){
//		boost::apply_visitor(PrintVisitor{stream}, s);
// 		stream << "|";
//	}
//    return stream << "}";
// }

namespace protocute {
struct IStream {
	virtual void read(void *data, size_t size)=0;
	virtual void skip(size_t size){
		std::vector<uint8_t> temp(size);
		read(temp.data(), temp.size());
	}
	virtual bool empty()const=0;
};
struct OStream {
	virtual void write(const void *data, size_t size)=0;
};

struct StringStream : public IStream, public OStream {
	void write(const void *data, size_t size) override {
		str.append(static_cast<const char *>(data), size);
	}
	void read(void *data, size_t size) override{
		if(in_position + size > str.size())
			throw std::runtime_error("protocute::StringStream underflow");
		memcpy(data, str.data() + in_position, size);
		in_position += size;
	}
	bool empty()const override{
		return in_position == str.size();
	}
	std::string str;
	size_t in_position = 0;
};

} // namespace protocute

struct Inner {
	int val = 0; // id = 1
};

struct Example {
	int field_a = 0; // id = 3
	std::string field_b; // id = 4
	Inner field_c; // id = 5
};

namespace protocute {

uint64_t read_varint(IStream * s){
	return 0;
}
size_t read_varint_size_t(IStream * s){
	return static_cast<size_t>(read_varint(s));
}
void write_varint(uint64_t v, OStream * s){
}

std::string read_string(IStream * s){
	auto len = read_varint_size_t(s);
	std::string str;
	str.resize(len);
	s->read(&str[0], len);
	return str;
}
//void write_string(const std::string & v, OStream * s){
//	write_varint(v.size(), s);
//	s->write(v.data(), v.size());
//}

void write_field_int(unsigned field_number, uint64_t v, OStream * s){
	write_varint((field_number << 7) | 0, s);
	write_varint(v, s);
}

void write_field_string(unsigned field_number, const std::string & v, OStream * s){
	write_varint((field_number << 7) | 2, s);
	write_varint(v.size(), s);
	s->write(v.data(), v.size());
}

template<class T>
std::string write_message(const T & v){
	StringStream s2;
	write(v, &s2);
	return s2.str;
}

template<class T>
void read_message(T & v, IStream * s){
	auto len = read_varint_size_t(s);
	StringStream s2;
	s2.str.resize(len);
	s->read(&s2.str[0], len);;
	read(v, &s2);
}

void skip_by_type(unsigned field_type, IStream * s){
	switch (field_type) {
  case 0:
    read_varint(s);
    break;
  case 1: // 64-bit fixed
    s->skip(8);
    break;
  case 2:
   	s->skip(read_varint_size_t(s));
    break;
  case 3: // start group
  case 4: // end group
  	throw std::runtime_error("groups are not supported");
  case 5:
    s->skip(4);
    break;
  default:
    break;
}
}

void read(::Inner & v, IStream * s){
}
void write(const ::Inner & v, OStream * s){
}

void read(::Example & v, IStream * s){
	while(!s->empty()){
		auto m = read_varint(s);
		unsigned field_type = unsigned(m & 7);
		unsigned field_number = unsigned(m >> 3);
		if(field_number == 1 && field_type == 0)
			v.field_a = static_cast<int>(read_varint(s));
		else if(field_number == 3 && field_type == 2)
			v.field_b = read_string(s);
		else if(field_number == 4 && field_type == 2)
			read_message(v.field_c, s);
		else
			skip_by_type(field_type, s);
	}
}

void write(const ::Example & v, OStream * s){
	if(v.field_a != 1)
		write_field_int(3, v.field_a, s);
	if(!v.field_b.empty())
		write_field_string(4, v.field_b, s);
	write_field_string(5, write_message(v.field_c), s);
}

}


int main(int argc, const char * argv[])
{
	test_rules();
	char cwd[PATH_MAX] = {};
	if (!getcwd(cwd, sizeof(cwd))) {
		perror("getcwd() error");
		return 1;
	}
	printf("Current working dir: %s\n", cwd);

	std::vector<std::string> spl;
	bool a1 = parse_ident_split("a.bcd.ef", spl);
	bool a2 = parse_ident_split("bcd.ef1-", spl);
	bool a3 = parse_ident_split("bcd", spl);
	GProtoFile result;

//	bool ok = parse_proto("syntax = \"proto2\";\npackage hw.trezor.messages.common;; enum EnumAllowingAlias {A=1; B=2;} message Outer{}", result);
//	std::cout << int(ok) << " " << result << std::endl;
	
	std::ifstream t("c.proto");
	std::string str(std::istreambuf_iterator<char>{t},
                 std::istreambuf_iterator<char>{});

//	result = GProtoFile{};
	bool ok = parse_proto(str, result);
	std::cout << int(ok) << " " << result << std::endl;

	std::ofstream hpp("c.hpp");
	std::ofstream cpp("c.cpp");

	CodeGenerator generator(hpp, cpp);
	
	for(const auto & s : result.fields){
		boost::apply_visitor(generator, s);
	}
	
	generator.finish_header();

//	std::cout << str << std::endl;
	return 0;
}
