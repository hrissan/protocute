#include "proto.hpp"
#include "protocute.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <complex>
#include <unistd.h>

static std::string boast = "// This file is generated by https://github.com/hrissan/protocute\n\n";

static std::string stream_def = R"(

	namespace protocute {
	struct IStream {
		virtual void read(void *data, size_t size)=0;
	};
	struct OStream {
		virtual void write(const void *data, size_t size)=0;
	};
	} // namespace protocute

)";


struct Namespace;

struct Namespace {
	enum Type { PACKAGE, MESSAGE, ENUM, BUILTIN };
	Type type = PACKAGE;
	std::string fullname;
	std::map<std::string, std::unique_ptr<Namespace>> member;
	
	std::string enum_default_value;
	bool has_sign = false;
};

struct CodeGenerator {
	std::ofstream hpp;
	std::ofstream cpp;
	
	std::vector<std::string> current_package;
	
	Namespace root_namespace;
	std::vector<Namespace *> current_namespace;
	size_t indent = 0; // signle indent for a::b::c::d
	
	struct EnumGenerator {
		CodeGenerator & cg;
		explicit EnumGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s) {}
		void operator()(GEnum const& s);
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};
	struct MessageGenerator {
		CodeGenerator & cg;
		explicit MessageGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s) {}
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s);
		void operator()(GEmptyStatement const& s) {}
	};
	struct FieldGenerator {
		CodeGenerator & cg;
		size_t total_count = 0;
		explicit FieldGenerator(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s);
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};
	struct FieldGeneratorRead {
		CodeGenerator & cg;
		explicit FieldGeneratorRead(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s);
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};
	struct FieldGeneratorWrite {
		CodeGenerator & cg;
		explicit FieldGeneratorWrite(CodeGenerator & cg):cg(cg){
		}
		void operator()(GField const& s);
		void operator()(GEnum const& s) {}
		void operator()(GOption const& s) {}
		void operator()(GMessage const& s) {}
		void operator()(GEmptyStatement const& s) {}
	};
	void close_package(){
		if(current_package.empty())
			return;
		hpp << std::string(current_package.size(), '}') << " // ";
		std::string fullname;
		for(const auto & s : current_package){
			if(!fullname.empty())
				fullname += "::";
			fullname += s;
		}
		hpp << fullname << "\n\n";
		current_package.clear();
		current_namespace = {&root_namespace};
		indent = 0;
	}
	void add_builtin(const std::string & fullname, const std::string & cppname, const std::string & def, bool has_sign = false){
		auto cit = root_namespace.member.find(fullname);
		if(cit != root_namespace.member.end())
			throw std::runtime_error("Builtin name collision");
		cit = root_namespace.member.emplace(fullname, std::make_unique<Namespace>()).first;
		cit->second->type = Namespace::BUILTIN;
		cit->second->fullname = cppname;
		cit->second->enum_default_value = def;
		cit->second->has_sign = has_sign;
	}
	explicit CodeGenerator(const std::string & path, const std::string & name):hpp(path + "/" + name + ".hpp"), cpp(path + "/" + name + ".cpp") {
		hpp << boast;
		hpp << "#include <string>\n";
		hpp << "#include <vector>\n";
		hpp << "#include <cstdint>\n\n";
		
		cpp << boast;
		
		cpp << "#include \"" << name << ".hpp\"\n";
		cpp << "#include \"protocute.hpp\"\n\n";

		cpp << "namespace protocute {\n\n";
		current_namespace = {&root_namespace};
		add_builtin("double", "double", "0");
		add_builtin("float", "float", "0");
		add_builtin("int32", "int32_t", "0", true);
		add_builtin("sint32", "int32_t", "0", true);
		add_builtin("sfixed32", "int32_t", "0", true);
		add_builtin("uint32", "uint32_t", "0");
		add_builtin("fixed32", "uint32_t", "0");
		add_builtin("int64", "int64_t", "0", true);
		add_builtin("sint64", "int64_t", "0", true);
		add_builtin("sfixed64", "int64_t", "0", true);
		add_builtin("uint64", "uint64_t", "0");
		add_builtin("fixed64", "uint64_t", "0");
		add_builtin("bool", "bool", "false");
		add_builtin("string", "std::string", "std::string{}");
		add_builtin("bytes", "std::string", "std::string{}");
	}
	
	void operator()(GImport const& s) {}
	void operator()(std::string const& s)
	{
		close_package();
		if(!parse_ident_split(s, current_package))
			throw std::runtime_error("Error parsing package name {" + s + "}");
		for(const auto & s : current_package){
			hpp << "namespace " << s << " { ";
			auto cn = current_namespace.back();
			auto cit = cn->member.find(s);
			if(cit == cn->member.end())
				cit = cn->member.emplace(s, std::make_unique<Namespace>()).first;
			cit->second->fullname = cn->fullname + "::" + s;
			if(cit->second->type != Namespace::PACKAGE)
				throw std::runtime_error("Package name collision with non-package");
			current_namespace.push_back(cit->second.get());
		}
		hpp << "\n\n";
		indent = 1;
	}
	void operator()(GOption const& s)
	{
	}
	void operator()(GEnum const& s){
		auto cn = current_namespace.back();
		auto cit = cn->member.find(s.name);
		if(cit != cn->member.end())
			throw std::runtime_error("Enum name collision");
		cit = cn->member.emplace(s.name, std::make_unique<Namespace>()).first;
		cit->second->fullname = cn->fullname + "::" + s.name;
		cit->second->type = Namespace::ENUM;
		hpp << std::string(indent, '\t') << "enum " << s.name << " {";
		bool first_field = true;
		for(const auto & f : s.fields)
			if(f.type() == typeid(GEnumField)){
				const auto & ef = boost::get<GEnumField>(f);
				if(cit->second->enum_default_value.empty())
					cit->second->enum_default_value = ef.name;
				if(!first_field)
					hpp << ",";
				first_field = false;
				hpp << "\n" << std::string(indent + 1, '\t') << ef.name << " = " << ef.value;
			}
//			else if(f.type() == typeid(GOption))
//				stream << boost::get<GOption>(f) << "|";
		hpp << "\n" << std::string(indent, '\t') << "};\n\n";
	}
	void operator()(GMessage const& s){
		hpp << std::string(indent, '\t') << "struct " << s.name << " { \n";
		auto cn = current_namespace.back();
		auto cit = cn->member.find(s.name);
		if(cit != cn->member.end())
			throw std::runtime_error("Message name collision");
		cit = cn->member.emplace(s.name, std::make_unique<Namespace>()).first;
		cit->second->fullname = cn->fullname + "::" + s.name;
		cit->second->type = Namespace::MESSAGE;
		current_namespace.push_back(cit->second.get());
		indent += 1;

		EnumGenerator eg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(eg, f);
		MessageGenerator mg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(mg, f);
		FieldGenerator fg(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(fg, f);
		
		cpp << "\tvoid read(" << cit->second->fullname << " & v, iterator s, iterator e){\n";
		cpp << "\t\twhile(s != e){\n";
		cpp << "\t\t\tauto m = read_varint(&s, e);\n";
		cpp << "\t\t\tauto field_type = static_cast<unsigned>(m & 7);\n";
		if(fg.total_count != 0)
			cpp << "\t\t\tauto field_number = static_cast<unsigned>(m >> 3);\n";
		cpp << "\t\t\t";

		FieldGeneratorRead fgr(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(fgr, f);
		if(fg.total_count != 0)
			cpp << "\n\t\t\t\t";
		cpp << "skip_by_type(field_type, &s, e);\n";
		cpp << "\t\t}\n\n";
		cpp << "\t}\n\n";
		cpp << "\tstd::string write(const " << cit->second->fullname << " & v){\n";
		cpp << "\t\tstd::string s;\n";
		FieldGeneratorWrite fgw(*this);
		for(const auto & f : s.fields)
			boost::apply_visitor(fgw, f);
		cpp << "\t\treturn s;\n";
		cpp << "\t}\n\n";

		current_namespace.pop_back();
		indent -= 1;
		hpp << std::string(indent, '\t') << "};\n\n";
	}
	void operator()(GEmptyStatement const& s) {}
	Namespace * resolve_type(const std::string & name){
		std::string str = name;
		if(str.empty())
			throw std::runtime_error("Type cannot be empty");
		size_t pos = current_namespace.size();
		if(str.at(0) == '.'){
			pos = 1;
			str.erase(str.begin());
		}
		std::vector<std::string> full_ident;
		if(!parse_ident_split(str, full_ident) || full_ident.empty())
			throw std::runtime_error("Error parsing full identifer name {" + str + "}");
		Namespace * found_cn = nullptr;
		for(size_t i = pos; i-- > 0; ){
			auto cn = current_namespace.at(i);
			auto cit = cn->member.find(full_ident.at(0));
			if(cit != cn->member.end()){
				found_cn = cit->second.get();
				full_ident.erase(full_ident.begin());
				while(!full_ident.empty()){
					auto cit = found_cn->member.find(full_ident.at(0));
					if(cit == found_cn->member.end())
						throw std::runtime_error("Type not found - " + name);
					found_cn = cit->second.get();
					full_ident.erase(full_ident.begin());
				}
				break;
			}
		}
		if(!found_cn)
			throw std::runtime_error("Type not found - " + name);
		if(found_cn->type == Namespace::PACKAGE)
			throw std::runtime_error("Type specified is a package - " + name);
		return found_cn;
	}
	void generate_field_read(GField const& s){
		auto found_cn = resolve_type(s.type);
		cpp << "if(field_number == " << s.number << " && field_type == ";
		std::string ass = "\t\t\t\tv." + s.name + " = ";
		std::string ass2 = "";
		if( s.kind == GFieldKind::REPEATED){
			ass = "\t\t\t\tv." + s.name + ".push_back(";
			ass2 = ")";
		}
		if(found_cn->fullname == "uint32_t")
			cpp << "0)\n" << ass << "static_cast<uint32_t>(read_varint(&s, e))" << ass2 << ";\n\t\t\t";
		else if(found_cn->fullname == "uint64_t")
			cpp << "0)\n" << ass << "read_varint(&s, e)" << ass2 << ";\n\t\t\t";
		else if(s.type == "sint32")
			cpp << "0)\n" << ass << "unzip_sint32(read_varint(&s, e))" << ass2 << ";\n\t\t\t";
		else if(found_cn->fullname == "int32_t")
			cpp << "0)\n" << ass << "static_cast<int32_t>(static_cast<int64_t>(read_varint(&s, e)))" << ass2 << ";\n\t\t\t";
		else if(s.type == "sint64")
			cpp << "0)\n" << ass << "unzip_sint64(read_varint(&s, e))" << ass2 << ";\n\t\t\t";
		else if(found_cn->fullname == "int64_t")
			cpp << "0)\n" << ass << "static_cast<int64_t>(read_varint(&s, e))" << ass2 << ";\t\t\t\t";
		else if(found_cn->fullname == "bool")
			cpp << "0)\n" << ass << "read_varint(&s, e) != 0" << ass2 << ";\n\t\t\t";
		else if(found_cn->type == Namespace::ENUM)
			cpp << "0)\n" << ass << "static_cast<" << found_cn->fullname << ">(read_varint(&s, e))" << ass2 << ";\n\t\t\t";
		else if(found_cn->fullname == "std::string")
			cpp << "2)\n" << ass << "read_string(&s, e)" << ass2 << ";\n\t\t\t";
		else {
			if( s.kind == GFieldKind::REPEATED){
				cpp << "2){\n\t\t\t\t" << s.name << ".resize(" << s.name << ".size() + 1);\n";
				cpp << "\t\t\t\tread_message(v." << s.name << ".back(), &s, e);\n\t\t\t}";
			}else{
				cpp << "\t\t\t\tread_message(v." << s.name << ", &s, e);\n\t\t\t";
			}
		}
		cpp << "else ";
//		if(field_number == 3 && field_type == 0)
//			v.field_a = static_cast<int>(read_varint(&s, e));
//		else if(field_number == 4 && field_type == 2)
//			v.field_b = read_string(&s, e);
//		else if(field_number == 5 && field_type == 2)
//			read_message(v.field_c, &s, e);
//		else if(field_number == 6 && field_type == 0)
//			v.field_d.push_back(static_cast<int>(read_varint(&s, e)));
//		else if(field_number == 6 && field_type == 2)
//			v.field_d.push_back(static_cast<int>(read_varint(&s, e)));
//		else
	}
	void generate_field_write(GField const& s){
		auto found_cn = resolve_type(s.type);
		size_t n_tabs = 2;
		if( s.kind == GFieldKind::REPEATED){
			// TODO - packed fields
			cpp << "\t\tfor(const auto & vv : v." << s.name <<")\n";
			n_tabs += 3;
		}
		if( !found_cn->enum_default_value.empty() ){
			if(found_cn->enum_default_value == "false"){
				cpp << std::string(n_tabs, '\t') << "if(v."<< s.name << ")\n";
			}else if(found_cn->enum_default_value == "std::string{}"){
				cpp << std::string(n_tabs, '\t') << "if(!v." << s.name << ".empty())\n";
			}else if(found_cn->type == Namespace::ENUM){
				cpp << std::string(n_tabs, '\t') << "if(v." << s.name << " != " << found_cn->fullname << "::" << found_cn->enum_default_value << ")\n";
			}else {
				cpp << std::string(n_tabs, '\t') << "if(v." << s.name << " != " << found_cn->enum_default_value << ")\n";
			}
			n_tabs += 1;
		}
		if(found_cn->fullname == "uint32_t" || found_cn->fullname == "uint64_t")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", v." << s.name << ", s);\n";
		else if(s.type == "sint32")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", zip_sint32(v." << s.name << "), s);\n";
		else if(found_cn->fullname == "int32_t")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", static_cast<uint64_t>(static_cast<int64_t>(v." << s.name << ")), s);\n";
		else if(s.type == "sint64")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", zip_sint64(v." << s.name << "), s);\n";
		else if(found_cn->fullname == "int64_t")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", static_cast<uint64_t>(v." << s.name << "), s);\n";
		else if(found_cn->fullname == "bool")
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", v." << s.name << " ? 1 : 0, s);\n";
		else if(found_cn->type == Namespace::ENUM)
			cpp << std::string(n_tabs, '\t') << "write_field_varint(" << s.number << ", static_cast<uint64_t>(v." << s.name << "), s);\n";
		else if(found_cn->fullname == "std::string")
			cpp << std::string(n_tabs, '\t') << "write_field_string(" << s.number << ", v." << s.name << ", s);\n";
		else
			cpp << std::string(n_tabs, '\t') << "write_field_string(" << s.number << ", write(v." << s.name << "), s);\n";
	}
	void generate_field(GField const& s){
		hpp << std::string(indent, '\t');
		if(s.kind == GFieldKind::REPEATED){
			hpp << "std::vector<";
		}
		auto found_cn = resolve_type(s.type);
		hpp << found_cn->fullname;
		if(s.kind == GFieldKind::REPEATED){
			hpp << ">";
		}
		hpp << " " << s.name;
		if(!found_cn->enum_default_value.empty() && found_cn->enum_default_value != "std::string{}")
			hpp << " = " << found_cn->enum_default_value;
		hpp << ";\n";
	}
	void gen_defs(const Namespace & na){
		if(na.type == Namespace::MESSAGE){
			hpp << "\tvoid read(" << na.fullname << " & v, iterator s, iterator e);\n";
			hpp << "\tstd::string write(const " << na.fullname << " & v);\n\n";
		}
		for(const auto & m : na.member){
			gen_defs(*m.second.get());
		}
	}
	void finish_header(){
		close_package();
		hpp << "namespace protocute {\n\n";
		hpp << "\ttypedef std::string::const_iterator iterator;\n\n";

		gen_defs(root_namespace);
		hpp << "} // namespace protocute\n\n";
		
		cpp << "} // namespace protocute\n\n";
	}
};

void CodeGenerator::EnumGenerator::operator()(GEnum const& s){
	cg.operator()(s);
}

void CodeGenerator::MessageGenerator::operator()(GMessage const& s) {
	cg.operator()(s);
}

void CodeGenerator::FieldGenerator::operator()(GField const& s){
	total_count += 1;
	cg.generate_field(s);
}

void CodeGenerator::FieldGeneratorRead::operator()(GField const& s){
	cg.generate_field_read(s);
}
void CodeGenerator::FieldGeneratorWrite::operator()(GField const& s){
	cg.generate_field_write(s);
}

int generate()
{
	test_rules();
	char cwd[PATH_MAX] = {};
	if (!getcwd(cwd, sizeof(cwd))) {
		perror("getcwd() error");
		return 1;
	}
	printf("Current working dir: %s\n", cwd);

	std::vector<std::string> spl;
	bool a1 = parse_ident_split("a.bcd.ef", spl);
	bool a2 = parse_ident_split("bcd.ef1-", spl);
	bool a3 = parse_ident_split("bcd", spl);
	GProtoFile result;

//	bool ok = parse_proto("syntax = \"proto2\";\npackage hw.trezor.messages.common;; enum EnumAllowingAlias {A=1; B=2;} message Outer{}", result);
//	std::cout << int(ok) << " " << result << std::endl;
	
	std::ifstream t("test.proto");
	std::string str(std::istreambuf_iterator<char>{t},
                 std::istreambuf_iterator<char>{});

//	result = GProtoFile{};
	bool ok = parse_proto(str, result);
	std::cout << int(ok) << " " << result << std::endl;

	CodeGenerator generator(cwd, "test");
	
	for(const auto & s : result.fields){
		boost::apply_visitor(generator, s);
	}
	
	generator.finish_header();

//	std::cout << str << std::endl;
	return 0;
}

#include "test.hpp"

int main(int argc, const char * argv[])
{
	generate();
	::hw::trezor::messages::common::HDNodeType node, node2;
	node.depth = 1;
	node.chain_code = "hren";
	std::string str = protocute::write(node);
	
	protocute::read(node2, str.begin(), str.end());
	return 0;
}
